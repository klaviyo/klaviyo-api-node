/**
 * Klaviyo API
 * The Klaviyo REST API. Please visit https://developers.klaviyo.com for more details.
 *
 * Contact: developers@klaviyo.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


const axios = require('axios');
import {AxiosRequestConfig, AxiosResponse} from "axios";
import FormData from 'form-data'

/* tslint:disable:no-unused-locals */
import { DeleteTagGroupResponse } from '../model/deleteTagGroupResponse';
import { GetAccounts4XXResponse } from '../model/getAccounts4XXResponse';
import { GetTagCampaignRelationshipsResponseCollection } from '../model/getTagCampaignRelationshipsResponseCollection';
import { GetTagFlowRelationshipsResponseCollection } from '../model/getTagFlowRelationshipsResponseCollection';
import { GetTagGroupResponse } from '../model/getTagGroupResponse';
import { GetTagGroupResponseCollection } from '../model/getTagGroupResponseCollection';
import { GetTagGroupTagRelationshipsResponseCollection } from '../model/getTagGroupTagRelationshipsResponseCollection';
import { GetTagListRelationshipsResponseCollection } from '../model/getTagListRelationshipsResponseCollection';
import { GetTagResponseCollection } from '../model/getTagResponseCollection';
import { GetTagResponseCollectionCompoundDocument } from '../model/getTagResponseCollectionCompoundDocument';
import { GetTagResponseCompoundDocument } from '../model/getTagResponseCompoundDocument';
import { GetTagSegmentRelationshipsResponseCollection } from '../model/getTagSegmentRelationshipsResponseCollection';
import { GetTagTagGroupRelationshipsResponse } from '../model/getTagTagGroupRelationshipsResponse';
import { PatchTagGroupResponse } from '../model/patchTagGroupResponse';
import { PostTagGroupResponse } from '../model/postTagGroupResponse';
import { PostTagResponse } from '../model/postTagResponse';
import { TagCampaignOp } from '../model/tagCampaignOp';
import { TagCreateQuery } from '../model/tagCreateQuery';
import { TagFlowOp } from '../model/tagFlowOp';
import { TagGroupCreateQuery } from '../model/tagGroupCreateQuery';
import { TagGroupUpdateQuery } from '../model/tagGroupUpdateQuery';
import { TagListOp } from '../model/tagListOp';
import { TagSegmentOp } from '../model/tagSegmentOp';
import { TagUpdateQuery } from '../model/tagUpdateQuery';

import { ObjectSerializer } from '../model/models';

import {RequestFile, queryParamPreProcessor, RetryWithExponentialBackoff, Session} from './apis';

let defaultBasePath = 'https://a.klaviyo.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================


export class TagsApi {

    session: Session

    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    constructor(session: Session){
        this.session = session
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    /**
     * Create a tag. An account cannot have more than **500** unique tags.  A tag belongs to a single tag group. If the `tag_group_id` is not specified, the tag is added to the account\'s default tag group.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read` `tags:write`
     * @summary Create Tag
     * @param tagCreateQuery 
     
     */
    public async createTag (tagCreateQuery: TagCreateQuery, ): Promise<{ response: AxiosResponse; body: PostTagResponse;  }> {

        const localVarPath = this.basePath + '/api/tags';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'tagCreateQuery' is not null or undefined
        if (tagCreateQuery === null || tagCreateQuery === undefined) {
            throw new Error('Required parameter tagCreateQuery was null or undefined when calling createTag.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'POST',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagCreateQuery, "TagCreateQuery")
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: PostTagResponse;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "PostTagResponse");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Create a tag group. An account cannot have more than **50** unique tag groups.  If `exclusive` is not specified `true` or `false`, the tag group defaults to non-exclusive.  If a tag group is non-exclusive, any given related resource (campaign, flow, etc.) can be linked to multiple tags from that tag group. If a tag group is exclusive, any given related resource can only be linked to one tag from that tag group.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read` `tags:write`
     * @summary Create Tag Group
     * @param tagGroupCreateQuery 
     
     */
    public async createTagGroup (tagGroupCreateQuery: TagGroupCreateQuery, ): Promise<{ response: AxiosResponse; body: PostTagGroupResponse;  }> {

        const localVarPath = this.basePath + '/api/tag-groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'tagGroupCreateQuery' is not null or undefined
        if (tagGroupCreateQuery === null || tagGroupCreateQuery === undefined) {
            throw new Error('Required parameter tagGroupCreateQuery was null or undefined when calling createTagGroup.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'POST',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagGroupCreateQuery, "TagGroupCreateQuery")
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: PostTagGroupResponse;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "PostTagGroupResponse");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Delete the tag with the given tag ID. Any associations between the tag and other resources will also be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read` `tags:write`
     * @summary Delete Tag
     * @param id The Tag ID
     
     */
    public async deleteTag (id: string, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTag.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body?: any;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Delete the tag group with the given tag group ID.  Any tags inside that tag group, and any associations between those tags and other resources, will also be removed. The default tag group cannot be deleted.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read` `tags:write`
     * @summary Delete Tag Group
     * @param id The Tag Group ID
     
     */
    public async deleteTagGroup (id: string, ): Promise<{ response: AxiosResponse; body: DeleteTagGroupResponse;  }> {

        const localVarPath = this.basePath + '/api/tag-groups/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTagGroup.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: DeleteTagGroupResponse;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "DeleteTagGroupResponse");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Returns the IDs of all campaigns associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `campaigns:read` `tags:read`
     * @summary Get Campaign IDs for Tag
     * @param id The Tag ID
     
     */
    public async getCampaignIdsForTag (id: string, ): Promise<{ response: AxiosResponse; body: GetTagCampaignRelationshipsResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/campaigns'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCampaignIdsForTag.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: GetTagCampaignRelationshipsResponseCollection;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagCampaignRelationshipsResponseCollection");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Returns the IDs of all flows associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `flows:read` `tags:read`
     * @summary Get Flow IDs for Tag
     * @param id The Tag ID
     
     */
    public async getFlowIdsForTag (id: string, ): Promise<{ response: AxiosResponse; body: GetTagFlowRelationshipsResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/flows'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getFlowIdsForTag.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: GetTagFlowRelationshipsResponseCollection;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagFlowRelationshipsResponseCollection");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Returns the IDs of all lists associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `lists:read` `tags:read`
     * @summary Get List IDs for Tag
     * @param id The Tag ID
     
     */
    public async getListIdsForTag (id: string, ): Promise<{ response: AxiosResponse; body: GetTagListRelationshipsResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/lists'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getListIdsForTag.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: GetTagListRelationshipsResponseCollection;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagListRelationshipsResponseCollection");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Returns the IDs of all segments associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `segments:read` `tags:read`
     * @summary Get Segment IDs for Tag
     * @param id The Tag ID
     
     */
    public async getSegmentIdsForTag (id: string, ): Promise<{ response: AxiosResponse; body: GetTagSegmentRelationshipsResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/segments'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSegmentIdsForTag.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: GetTagSegmentRelationshipsResponseCollection;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagSegmentRelationshipsResponseCollection");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Retrieve the tag with the given tag ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tag
     * @param id The Tag ID
     * @param fieldsTagGroup For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#sparse-fieldsets* @param fieldsTag For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#sparse-fieldsets* @param include For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#relationships
     */
    public async getTag (id: string, options: { fieldsTagGroup?: Array<'name' | 'exclusive' | 'default'>, fieldsTag?: Array<'name'>, include?: Array<'tag-group'>,  } = {}): Promise<{ response: AxiosResponse; body: GetTagResponseCompoundDocument;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTag.');
        }

        if (options.fieldsTagGroup !== undefined) {
            localVarQueryParameters['fields[tag-group]'] = ObjectSerializer.serialize(options.fieldsTagGroup, "Array<'name' | 'exclusive' | 'default'>");
        }

        if (options.fieldsTag !== undefined) {
            localVarQueryParameters['fields[tag]'] = ObjectSerializer.serialize(options.fieldsTag, "Array<'name'>");
        }

        if (options.include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(options.include, "Array<'tag-group'>");
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: GetTagResponseCompoundDocument;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagResponseCompoundDocument");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Retrieve the tag group with the given tag group ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tag Group
     * @param id The Tag Group ID
     * @param fieldsTagGroup For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#sparse-fieldsets
     */
    public async getTagGroup (id: string, options: { fieldsTagGroup?: Array<'name' | 'exclusive' | 'default'>,  } = {}): Promise<{ response: AxiosResponse; body: GetTagGroupResponse;  }> {

        const localVarPath = this.basePath + '/api/tag-groups/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagGroup.');
        }

        if (options.fieldsTagGroup !== undefined) {
            localVarQueryParameters['fields[tag-group]'] = ObjectSerializer.serialize(options.fieldsTagGroup, "Array<'name' | 'exclusive' | 'default'>");
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: GetTagGroupResponse;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagGroupResponse");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Returns the tag group resource for a given tag ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tag Group for Tag
     * @param id The Tag ID
     * @param fieldsTagGroup For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#sparse-fieldsets
     */
    public async getTagGroupForTag (id: string, options: { fieldsTagGroup?: Array<'name' | 'exclusive' | 'default'>,  } = {}): Promise<{ response: AxiosResponse; body: GetTagGroupResponse;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/tag-group'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagGroupForTag.');
        }

        if (options.fieldsTagGroup !== undefined) {
            localVarQueryParameters['fields[tag-group]'] = ObjectSerializer.serialize(options.fieldsTagGroup, "Array<'name' | 'exclusive' | 'default'>");
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: GetTagGroupResponse;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagGroupResponse");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Returns the id of the tag group related to the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tag Group ID for Tag
     * @param id The Tag ID
     
     */
    public async getTagGroupIdForTag (id: string, ): Promise<{ response: AxiosResponse; body: GetTagTagGroupRelationshipsResponse;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/tag-group'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagGroupIdForTag.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: GetTagTagGroupRelationshipsResponse;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagTagGroupRelationshipsResponse");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * List all tag groups in an account. Every account has one default tag group.  Tag groups can be filtered by `name`, `exclusive`, and `default`, and sorted by `name` or `id` in ascending or descending order.  Returns a maximum of 25 tag groups per request, which can be paginated with [cursor-based pagination](https://developers.klaviyo.com/en/v2022-10-17/reference/api_overview#pagination).<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tag Groups
     
     * @param fieldsTagGroup For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#sparse-fieldsets* @param filter For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;name&#x60;: &#x60;contains&#x60;, &#x60;ends-with&#x60;, &#x60;equals&#x60;, &#x60;starts-with&#x60;&lt;br&gt;&#x60;exclusive&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;default&#x60;: &#x60;equals&#x60;* @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#pagination* @param sort For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#sorting
     */
    public async getTagGroups (options: { fieldsTagGroup?: Array<'name' | 'exclusive' | 'default'>, filter?: string, pageCursor?: string, sort?: 'id' | '-id' | 'name' | '-name',  } = {}): Promise<{ response: AxiosResponse; body: GetTagGroupResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tag-groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        if (options.fieldsTagGroup !== undefined) {
            localVarQueryParameters['fields[tag-group]'] = ObjectSerializer.serialize(options.fieldsTagGroup, "Array<'name' | 'exclusive' | 'default'>");
        }

        if (options.filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(options.filter, "string");
        }

        if (options.pageCursor !== undefined) {
            localVarQueryParameters['page[cursor]'] = ObjectSerializer.serialize(options.pageCursor, "string");
        }

        if (options.sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(options.sort, "'id' | '-id' | 'name' | '-name'");
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: GetTagGroupResponseCollection;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagGroupResponseCollection");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Returns the tag IDs of all tags inside the given tag group.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tag IDs for Tag Group
     * @param id The Tag Group ID
     
     */
    public async getTagIdsForTagGroup (id: string, ): Promise<{ response: AxiosResponse; body: GetTagGroupTagRelationshipsResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tag-groups/{id}/relationships/tags'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagIdsForTagGroup.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: GetTagGroupTagRelationshipsResponseCollection;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagGroupTagRelationshipsResponseCollection");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * List all tags in an account.  Tags can be filtered by `name`, and sorted by `name` or `id` in ascending or descending order.  Returns a maximum of 50 tags per request, which can be paginated with [cursor-based pagination](https://developers.klaviyo.com/en/v2022-10-17/reference/api_overview#pagination).<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tags
     
     * @param fieldsTagGroup For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#sparse-fieldsets* @param fieldsTag For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#sparse-fieldsets* @param filter For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;name&#x60;: &#x60;contains&#x60;, &#x60;ends-with&#x60;, &#x60;equals&#x60;, &#x60;starts-with&#x60;* @param include For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#relationships* @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#pagination* @param sort For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#sorting
     */
    public async getTags (options: { fieldsTagGroup?: Array<'name' | 'exclusive' | 'default'>, fieldsTag?: Array<'name'>, filter?: string, include?: Array<'tag-group'>, pageCursor?: string, sort?: 'id' | '-id' | 'name' | '-name',  } = {}): Promise<{ response: AxiosResponse; body: GetTagResponseCollectionCompoundDocument;  }> {

        const localVarPath = this.basePath + '/api/tags';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        if (options.fieldsTagGroup !== undefined) {
            localVarQueryParameters['fields[tag-group]'] = ObjectSerializer.serialize(options.fieldsTagGroup, "Array<'name' | 'exclusive' | 'default'>");
        }

        if (options.fieldsTag !== undefined) {
            localVarQueryParameters['fields[tag]'] = ObjectSerializer.serialize(options.fieldsTag, "Array<'name'>");
        }

        if (options.filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(options.filter, "string");
        }

        if (options.include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(options.include, "Array<'tag-group'>");
        }

        if (options.pageCursor !== undefined) {
            localVarQueryParameters['page[cursor]'] = ObjectSerializer.serialize(options.pageCursor, "string");
        }

        if (options.sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(options.sort, "'id' | '-id' | 'name' | '-name'");
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: GetTagResponseCollectionCompoundDocument;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagResponseCollectionCompoundDocument");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Return the tags for a given tag group ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tags for Tag Group
     * @param id The Tag Group ID
     * @param fieldsTag For more information please visit https://developers.klaviyo.com/en/v2024-10-15/reference/api-overview#sparse-fieldsets
     */
    public async getTagsForTagGroup (id: string, options: { fieldsTag?: Array<'name'>,  } = {}): Promise<{ response: AxiosResponse; body: GetTagResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tag-groups/{id}/tags'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagsForTagGroup.');
        }

        if (options.fieldsTag !== undefined) {
            localVarQueryParameters['fields[tag]'] = ObjectSerializer.serialize(options.fieldsTag, "Array<'name'>");
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: GetTagResponseCollection;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagResponseCollection");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Remove a tag\'s association with one or more campaigns.   Use the request body to pass in the ID(s) of the campaign(s) whose association with the tag will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `campaigns:write` `tags:write`
     * @summary Remove Tag from Campaigns
     * @param id The Tag ID* @param tagCampaignOp 
     
     */
    public async removeTagFromCampaigns (id: string, tagCampaignOp: TagCampaignOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/campaigns'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeTagFromCampaigns.');
        }

        // verify required parameter 'tagCampaignOp' is not null or undefined
        if (tagCampaignOp === null || tagCampaignOp === undefined) {
            throw new Error('Required parameter tagCampaignOp was null or undefined when calling removeTagFromCampaigns.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagCampaignOp, "TagCampaignOp")
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body?: any;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Remove a tag\'s association with one or more flows.   Use the request body to pass in the ID(s) of the flows(s) whose association with the tag will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `flows:write` `tags:write`
     * @summary Remove Tag from Flows
     * @param id The Tag ID* @param tagFlowOp 
     
     */
    public async removeTagFromFlows (id: string, tagFlowOp: TagFlowOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/flows'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeTagFromFlows.');
        }

        // verify required parameter 'tagFlowOp' is not null or undefined
        if (tagFlowOp === null || tagFlowOp === undefined) {
            throw new Error('Required parameter tagFlowOp was null or undefined when calling removeTagFromFlows.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagFlowOp, "TagFlowOp")
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body?: any;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Remove a tag\'s association with one or more lists.   Use the request body to pass in the ID(s) of the list(s) whose association with the tag will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `lists:write` `tags:write`
     * @summary Remove Tag from Lists
     * @param id The Tag ID* @param tagListOp 
     
     */
    public async removeTagFromLists (id: string, tagListOp: TagListOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/lists'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeTagFromLists.');
        }

        // verify required parameter 'tagListOp' is not null or undefined
        if (tagListOp === null || tagListOp === undefined) {
            throw new Error('Required parameter tagListOp was null or undefined when calling removeTagFromLists.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagListOp, "TagListOp")
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body?: any;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Remove a tag\'s association with one or more segments.   Use the request body to pass in the ID(s) of the segments(s) whose association with the tag will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `segments:write` `tags:write`
     * @summary Remove Tag from Segments
     * @param id The Tag ID* @param tagSegmentOp 
     
     */
    public async removeTagFromSegments (id: string, tagSegmentOp: TagSegmentOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/segments'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeTagFromSegments.');
        }

        // verify required parameter 'tagSegmentOp' is not null or undefined
        if (tagSegmentOp === null || tagSegmentOp === undefined) {
            throw new Error('Required parameter tagSegmentOp was null or undefined when calling removeTagFromSegments.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagSegmentOp, "TagSegmentOp")
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body?: any;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Associate a tag with one or more campaigns. Any campaign cannot be associated with more than **100** tags.   Use the request body to pass in the ID(s) of the campaign(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `campaigns:write` `tags:write`
     * @summary Tag Campaigns
     * @param id The Tag ID* @param tagCampaignOp 
     
     */
    public async tagCampaigns (id: string, tagCampaignOp: TagCampaignOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/campaigns'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tagCampaigns.');
        }

        // verify required parameter 'tagCampaignOp' is not null or undefined
        if (tagCampaignOp === null || tagCampaignOp === undefined) {
            throw new Error('Required parameter tagCampaignOp was null or undefined when calling tagCampaigns.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'POST',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagCampaignOp, "TagCampaignOp")
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body?: any;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Associate a tag with one or more flows. Any flow cannot be associated with more than **100** tags.   Use the request body to pass in the ID(s) of the flow(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `flows:write` `tags:write`
     * @summary Tag Flows
     * @param id The Tag ID* @param tagFlowOp 
     
     */
    public async tagFlows (id: string, tagFlowOp: TagFlowOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/flows'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tagFlows.');
        }

        // verify required parameter 'tagFlowOp' is not null or undefined
        if (tagFlowOp === null || tagFlowOp === undefined) {
            throw new Error('Required parameter tagFlowOp was null or undefined when calling tagFlows.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'POST',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagFlowOp, "TagFlowOp")
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body?: any;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Associate a tag with one or more lists. Any list cannot be associated with more than **100** tags.   Use the request body to pass in the ID(s) of the lists(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `lists:write` `tags:write`
     * @summary Tag Lists
     * @param id The Tag ID* @param tagListOp 
     
     */
    public async tagLists (id: string, tagListOp: TagListOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/lists'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tagLists.');
        }

        // verify required parameter 'tagListOp' is not null or undefined
        if (tagListOp === null || tagListOp === undefined) {
            throw new Error('Required parameter tagListOp was null or undefined when calling tagLists.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'POST',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagListOp, "TagListOp")
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body?: any;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Associate a tag with one or more segments. Any segment cannot be associated with more than **100** tags.   Use the request body to pass in the ID(s) of the segments(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `segments:write` `tags:write`
     * @summary Tag Segments
     * @param id The Tag ID* @param tagSegmentOp 
     
     */
    public async tagSegments (id: string, tagSegmentOp: TagSegmentOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/segments'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tagSegments.');
        }

        // verify required parameter 'tagSegmentOp' is not null or undefined
        if (tagSegmentOp === null || tagSegmentOp === undefined) {
            throw new Error('Required parameter tagSegmentOp was null or undefined when calling tagSegments.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'POST',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagSegmentOp, "TagSegmentOp")
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body?: any;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Update the tag with the given tag ID.  Only a tag\'s `name` can be changed. A tag cannot be moved from one tag group to another.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read` `tags:write`
     * @summary Update Tag
     * @param id The Tag ID* @param tagUpdateQuery 
     
     */
    public async updateTag (id: string, tagUpdateQuery: TagUpdateQuery, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTag.');
        }

        // verify required parameter 'tagUpdateQuery' is not null or undefined
        if (tagUpdateQuery === null || tagUpdateQuery === undefined) {
            throw new Error('Required parameter tagUpdateQuery was null or undefined when calling updateTag.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'PATCH',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagUpdateQuery, "TagUpdateQuery")
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body?: any;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
    /**
     * Update the tag group with the given tag group ID.  Only a tag group\'s `name` can be changed. A tag group\'s `exclusive` or `default` value cannot be changed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read` `tags:write`
     * @summary Update Tag Group
     * @param id The Tag Group ID* @param tagGroupUpdateQuery 
     
     */
    public async updateTagGroup (id: string, tagGroupUpdateQuery: TagGroupUpdateQuery, ): Promise<{ response: AxiosResponse; body: PatchTagGroupResponse;  }> {

        const localVarPath = this.basePath + '/api/tag-groups/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/vnd.api+json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTagGroup.');
        }

        // verify required parameter 'tagGroupUpdateQuery' is not null or undefined
        if (tagGroupUpdateQuery === null || tagGroupUpdateQuery === undefined) {
            throw new Error('Required parameter tagGroupUpdateQuery was null or undefined when calling updateTagGroup.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'PATCH',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagGroupUpdateQuery, "TagGroupUpdateQuery")
        }

        await this.session.applyToRequest(config)

        const request = async (config: AxiosRequestConfig, retried = false): Promise<{ response: AxiosResponse; body: PatchTagGroupResponse;  }> => {
            try {
                const axiosResponse = await this.session.requestWithRetry(config)
                let body;
                body = ObjectSerializer.deserialize(axiosResponse.data, "PatchTagGroupResponse");
                return ({response: axiosResponse, body: body});
            } catch (error) {
                if (await this.session.refreshAndRetry(error, retried)) {
                    await this.session.applyToRequest(config)
                    return request(config, true)
                }
                throw error
            }
        }

        return request(config)
    }
}

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.getCampaignIdsForTag}
     *
     * @deprecated Use {@link TagsApi.getCampaignIdsForTag} instead
     */
    getTagRelationshipsCampaigns: typeof TagsApi.prototype.getCampaignIdsForTag;
}
TagsApi.prototype.getTagRelationshipsCampaigns = TagsApi.prototype.getCampaignIdsForTag

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.getFlowIdsForTag}
     *
     * @deprecated Use {@link TagsApi.getFlowIdsForTag} instead
     */
    getTagRelationshipsFlows: typeof TagsApi.prototype.getFlowIdsForTag;
}
TagsApi.prototype.getTagRelationshipsFlows = TagsApi.prototype.getFlowIdsForTag

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.getListIdsForTag}
     *
     * @deprecated Use {@link TagsApi.getListIdsForTag} instead
     */
    getTagRelationshipsLists: typeof TagsApi.prototype.getListIdsForTag;
}
TagsApi.prototype.getTagRelationshipsLists = TagsApi.prototype.getListIdsForTag

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.getSegmentIdsForTag}
     *
     * @deprecated Use {@link TagsApi.getSegmentIdsForTag} instead
     */
    getTagRelationshipsSegments: typeof TagsApi.prototype.getSegmentIdsForTag;
}
TagsApi.prototype.getTagRelationshipsSegments = TagsApi.prototype.getSegmentIdsForTag

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.getTagGroupForTag}
     *
     * @deprecated Use {@link TagsApi.getTagGroupForTag} instead
     */
    getTagTagGroup: typeof TagsApi.prototype.getTagGroupForTag;
}
TagsApi.prototype.getTagTagGroup = TagsApi.prototype.getTagGroupForTag

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.getTagGroupIdForTag}
     *
     * @deprecated Use {@link TagsApi.getTagGroupIdForTag} instead
     */
    getTagRelationshipsTagGroup: typeof TagsApi.prototype.getTagGroupIdForTag;
}
TagsApi.prototype.getTagRelationshipsTagGroup = TagsApi.prototype.getTagGroupIdForTag

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.getTagIdsForTagGroup}
     *
     * @deprecated Use {@link TagsApi.getTagIdsForTagGroup} instead
     */
    getTagGroupRelationshipsTags: typeof TagsApi.prototype.getTagIdsForTagGroup;
}
TagsApi.prototype.getTagGroupRelationshipsTags = TagsApi.prototype.getTagIdsForTagGroup

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.getTagsForTagGroup}
     *
     * @deprecated Use {@link TagsApi.getTagsForTagGroup} instead
     */
    getTagGroupTags: typeof TagsApi.prototype.getTagsForTagGroup;
}
TagsApi.prototype.getTagGroupTags = TagsApi.prototype.getTagsForTagGroup

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.removeTagFromCampaigns}
     *
     * @deprecated Use {@link TagsApi.removeTagFromCampaigns} instead
     */
    deleteTagRelationshipsCampaigns: typeof TagsApi.prototype.removeTagFromCampaigns;
}
TagsApi.prototype.deleteTagRelationshipsCampaigns = TagsApi.prototype.removeTagFromCampaigns

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.removeTagFromFlows}
     *
     * @deprecated Use {@link TagsApi.removeTagFromFlows} instead
     */
    deleteTagRelationshipsFlows: typeof TagsApi.prototype.removeTagFromFlows;
}
TagsApi.prototype.deleteTagRelationshipsFlows = TagsApi.prototype.removeTagFromFlows

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.removeTagFromLists}
     *
     * @deprecated Use {@link TagsApi.removeTagFromLists} instead
     */
    deleteTagRelationshipsLists: typeof TagsApi.prototype.removeTagFromLists;
}
TagsApi.prototype.deleteTagRelationshipsLists = TagsApi.prototype.removeTagFromLists

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.removeTagFromSegments}
     *
     * @deprecated Use {@link TagsApi.removeTagFromSegments} instead
     */
    deleteTagRelationshipsSegments: typeof TagsApi.prototype.removeTagFromSegments;
}
TagsApi.prototype.deleteTagRelationshipsSegments = TagsApi.prototype.removeTagFromSegments

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.tagCampaigns}
     *
     * @deprecated Use {@link TagsApi.tagCampaigns} instead
     */
    createTagRelationshipsCampaigns: typeof TagsApi.prototype.tagCampaigns;
}
TagsApi.prototype.createTagRelationshipsCampaigns = TagsApi.prototype.tagCampaigns

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.tagCampaigns}
     *
     * @deprecated Use {@link TagsApi.tagCampaigns} instead
     */
    createTagRelationshipsCampaign: typeof TagsApi.prototype.tagCampaigns;
}
TagsApi.prototype.createTagRelationshipsCampaign = TagsApi.prototype.tagCampaigns

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.tagFlows}
     *
     * @deprecated Use {@link TagsApi.tagFlows} instead
     */
    createTagRelationshipsFlows: typeof TagsApi.prototype.tagFlows;
}
TagsApi.prototype.createTagRelationshipsFlows = TagsApi.prototype.tagFlows

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.tagFlows}
     *
     * @deprecated Use {@link TagsApi.tagFlows} instead
     */
    createTagRelationshipsFlow: typeof TagsApi.prototype.tagFlows;
}
TagsApi.prototype.createTagRelationshipsFlow = TagsApi.prototype.tagFlows

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.tagLists}
     *
     * @deprecated Use {@link TagsApi.tagLists} instead
     */
    createTagRelationshipsLists: typeof TagsApi.prototype.tagLists;
}
TagsApi.prototype.createTagRelationshipsLists = TagsApi.prototype.tagLists

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.tagLists}
     *
     * @deprecated Use {@link TagsApi.tagLists} instead
     */
    createTagRelationshipsList: typeof TagsApi.prototype.tagLists;
}
TagsApi.prototype.createTagRelationshipsList = TagsApi.prototype.tagLists

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.tagSegments}
     *
     * @deprecated Use {@link TagsApi.tagSegments} instead
     */
    createTagRelationshipsSegments: typeof TagsApi.prototype.tagSegments;
}
TagsApi.prototype.createTagRelationshipsSegments = TagsApi.prototype.tagSegments

export interface TagsApi {
    /**
     * Alias of {@link TagsApi.tagSegments}
     *
     * @deprecated Use {@link TagsApi.tagSegments} instead
     */
    createTagRelationshipsSegment: typeof TagsApi.prototype.tagSegments;
}
TagsApi.prototype.createTagRelationshipsSegment = TagsApi.prototype.tagSegments

/**
 * Klaviyo API
 * The Klaviyo REST API. Please visit https://developers.klaviyo.com for more details.
 *
 * Contact: developers@klaviyo.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


const axios = require('axios');
import {AxiosRequestConfig, AxiosResponse} from "axios";
import { backOff, BackoffOptions } from 'exponential-backoff';
import FormData from 'form-data'

/* tslint:disable:no-unused-locals */
import { DeleteTagGroupResponse } from '../model/deleteTagGroupResponse';
import { GetAccounts4XXResponse } from '../model/getAccounts4XXResponse';
import { GetTagCampaignRelationshipsResponseCollection } from '../model/getTagCampaignRelationshipsResponseCollection';
import { GetTagFlowRelationshipsResponseCollection } from '../model/getTagFlowRelationshipsResponseCollection';
import { GetTagGroupResponse } from '../model/getTagGroupResponse';
import { GetTagGroupResponseCollection } from '../model/getTagGroupResponseCollection';
import { GetTagGroupTagRelationshipsResponseCollection } from '../model/getTagGroupTagRelationshipsResponseCollection';
import { GetTagListRelationshipsResponseCollection } from '../model/getTagListRelationshipsResponseCollection';
import { GetTagResponseCollection } from '../model/getTagResponseCollection';
import { GetTagResponseCollectionCompoundDocument } from '../model/getTagResponseCollectionCompoundDocument';
import { GetTagResponseCompoundDocument } from '../model/getTagResponseCompoundDocument';
import { GetTagSegmentRelationshipsResponseCollection } from '../model/getTagSegmentRelationshipsResponseCollection';
import { GetTagTagGroupRelationshipsResponse } from '../model/getTagTagGroupRelationshipsResponse';
import { PatchTagGroupResponse } from '../model/patchTagGroupResponse';
import { PostTagGroupResponse } from '../model/postTagGroupResponse';
import { PostTagResponse } from '../model/postTagResponse';
import { TagCampaignOp } from '../model/tagCampaignOp';
import { TagCreateQuery } from '../model/tagCreateQuery';
import { TagFlowOp } from '../model/tagFlowOp';
import { TagGroupCreateQuery } from '../model/tagGroupCreateQuery';
import { TagGroupUpdateQuery } from '../model/tagGroupUpdateQuery';
import { TagListOp } from '../model/tagListOp';
import { TagSegmentOp } from '../model/tagSegmentOp';
import { TagUpdateQuery } from '../model/tagUpdateQuery';

import { ObjectSerializer } from '../model/models';

import {RequestFile, queryParamPreProcessor, RetryOptions, Session} from './apis';

let defaultBasePath = 'https://a.klaviyo.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================


export class TagsApi {

    protected backoffOptions: BackoffOptions = new RetryOptions().options
    session: Session

    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {
        revision: "2023-09-15",
        "User-Agent": "klaviyo-api-node/6.0.1"
    };
    protected _useQuerystring : boolean = false;

    constructor(session: Session){
        this.session = session
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    /**
     * Create a tag. An account cannot have more than **500** unique tags.  A tag belongs to a single tag group. If the `tag_group_id` is not specified, the tag is added to the account\'s default tag group.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read` `tags:write`
     * @summary Create Tag
     * @param tagCreateQuery 
     
     */
    public async createTag (tagCreateQuery: TagCreateQuery, ): Promise<{ response: AxiosResponse; body: PostTagResponse;  }> {

        const localVarPath = this.basePath + '/api/tags/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'tagCreateQuery' is not null or undefined
        if (tagCreateQuery === null || tagCreateQuery === undefined) {
            throw new Error('Required parameter tagCreateQuery was null or undefined when calling createTag.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'POST',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagCreateQuery, "TagCreateQuery")
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: PostTagResponse;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: PostTagResponse;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "PostTagResponse");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Create a tag group. An account cannot have more than **50** unique tag groups.  If `exclusive` is not specified `true` or `false`, the tag group defaults to non-exclusive.  If a tag group is non-exclusive, any given related resource (campaign, flow, etc.) can be linked to multiple tags from that tag group. If a tag group is exclusive, any given related resource can only be linked to one tag from that tag group.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read` `tags:write`
     * @summary Create Tag Group
     * @param tagGroupCreateQuery 
     
     */
    public async createTagGroup (tagGroupCreateQuery: TagGroupCreateQuery, ): Promise<{ response: AxiosResponse; body: PostTagGroupResponse;  }> {

        const localVarPath = this.basePath + '/api/tag-groups/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'tagGroupCreateQuery' is not null or undefined
        if (tagGroupCreateQuery === null || tagGroupCreateQuery === undefined) {
            throw new Error('Required parameter tagGroupCreateQuery was null or undefined when calling createTagGroup.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'POST',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagGroupCreateQuery, "TagGroupCreateQuery")
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: PostTagGroupResponse;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: PostTagGroupResponse;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "PostTagGroupResponse");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Associate a tag with one or more campaigns. Any campaign cannot be associated with more than **100** tags.   Use the request body to pass in the ID(s) of the campaign(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `campaigns:write` `tags:write`
     * @summary Create Tag Relationships Campaigns
     * @param id * @param tagCampaignOp 
     
     */
    public async createTagRelationshipsCampaigns (id: string, tagCampaignOp: TagCampaignOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/campaigns/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createTagRelationshipsCampaigns.');
        }

        // verify required parameter 'tagCampaignOp' is not null or undefined
        if (tagCampaignOp === null || tagCampaignOp === undefined) {
            throw new Error('Required parameter tagCampaignOp was null or undefined when calling createTagRelationshipsCampaigns.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'POST',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagCampaignOp, "TagCampaignOp")
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body?: any;  }>( () => {
            return new Promise<{ response: AxiosResponse; body?: any;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Associate a tag with one or more flows. Any flow cannot be associated with more than **100** tags.   Use the request body to pass in the ID(s) of the flow(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `flows:write` `tags:write`
     * @summary Create Tag Relationships Flows
     * @param id * @param tagFlowOp 
     
     */
    public async createTagRelationshipsFlows (id: string, tagFlowOp: TagFlowOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/flows/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createTagRelationshipsFlows.');
        }

        // verify required parameter 'tagFlowOp' is not null or undefined
        if (tagFlowOp === null || tagFlowOp === undefined) {
            throw new Error('Required parameter tagFlowOp was null or undefined when calling createTagRelationshipsFlows.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'POST',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagFlowOp, "TagFlowOp")
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body?: any;  }>( () => {
            return new Promise<{ response: AxiosResponse; body?: any;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Associate a tag with one or more lists. Any list cannot be associated with more than **100** tags.   Use the request body to pass in the ID(s) of the lists(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `list:write` `tags:write`
     * @summary Create Tag Relationships Lists
     * @param id * @param tagListOp 
     
     */
    public async createTagRelationshipsLists (id: string, tagListOp: TagListOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/lists/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createTagRelationshipsLists.');
        }

        // verify required parameter 'tagListOp' is not null or undefined
        if (tagListOp === null || tagListOp === undefined) {
            throw new Error('Required parameter tagListOp was null or undefined when calling createTagRelationshipsLists.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'POST',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagListOp, "TagListOp")
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body?: any;  }>( () => {
            return new Promise<{ response: AxiosResponse; body?: any;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Associate a tag with one or more segments. Any segment cannot be associated with more than **100** tags.   Use the request body to pass in the ID(s) of the segments(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `segments:write` `tags:write`
     * @summary Create Tag Relationships Segments
     * @param id * @param tagSegmentOp 
     
     */
    public async createTagRelationshipsSegments (id: string, tagSegmentOp: TagSegmentOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/segments/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createTagRelationshipsSegments.');
        }

        // verify required parameter 'tagSegmentOp' is not null or undefined
        if (tagSegmentOp === null || tagSegmentOp === undefined) {
            throw new Error('Required parameter tagSegmentOp was null or undefined when calling createTagRelationshipsSegments.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'POST',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagSegmentOp, "TagSegmentOp")
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body?: any;  }>( () => {
            return new Promise<{ response: AxiosResponse; body?: any;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Delete the tag with the given tag ID. Any associations between the tag and other resources will also be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read` `tags:write`
     * @summary Delete Tag
     * @param id The Tag ID
     
     */
    public async deleteTag (id: string, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTag.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body?: any;  }>( () => {
            return new Promise<{ response: AxiosResponse; body?: any;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Delete the tag group with the given tag group ID.  Any tags inside that tag group, and any associations between those tags and other resources, will also be removed. The default tag group cannot be deleted.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read` `tags:write`
     * @summary Delete Tag Group
     * @param id The Tag Group ID
     
     */
    public async deleteTagGroup (id: string, ): Promise<{ response: AxiosResponse; body: DeleteTagGroupResponse;  }> {

        const localVarPath = this.basePath + '/api/tag-groups/{id}/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTagGroup.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: DeleteTagGroupResponse;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: DeleteTagGroupResponse;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "DeleteTagGroupResponse");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Remove a tag\'s association with one or more campaigns.   Use the request body to pass in the ID(s) of the campaign(s) whose association with the tag will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `campaigns:write` `tags:write`
     * @summary Delete Tag Relationships Campaigns
     * @param id * @param tagCampaignOp 
     
     */
    public async deleteTagRelationshipsCampaigns (id: string, tagCampaignOp: TagCampaignOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/campaigns/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTagRelationshipsCampaigns.');
        }

        // verify required parameter 'tagCampaignOp' is not null or undefined
        if (tagCampaignOp === null || tagCampaignOp === undefined) {
            throw new Error('Required parameter tagCampaignOp was null or undefined when calling deleteTagRelationshipsCampaigns.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagCampaignOp, "TagCampaignOp")
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body?: any;  }>( () => {
            return new Promise<{ response: AxiosResponse; body?: any;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Remove a tag\'s association with one or more flows.   Use the request body to pass in the ID(s) of the flows(s) whose association with the tag will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `flows:write` `tags:write`
     * @summary Delete Tag Relationships Flows
     * @param id * @param tagFlowOp 
     
     */
    public async deleteTagRelationshipsFlows (id: string, tagFlowOp: TagFlowOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/flows/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTagRelationshipsFlows.');
        }

        // verify required parameter 'tagFlowOp' is not null or undefined
        if (tagFlowOp === null || tagFlowOp === undefined) {
            throw new Error('Required parameter tagFlowOp was null or undefined when calling deleteTagRelationshipsFlows.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagFlowOp, "TagFlowOp")
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body?: any;  }>( () => {
            return new Promise<{ response: AxiosResponse; body?: any;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Remove a tag\'s association with one or more lists.   Use the request body to pass in the ID(s) of the list(s) whose association with the tag will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `list:write` `tags:write`
     * @summary Delete Tag Relationships Lists
     * @param id * @param tagListOp 
     
     */
    public async deleteTagRelationshipsLists (id: string, tagListOp: TagListOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/lists/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTagRelationshipsLists.');
        }

        // verify required parameter 'tagListOp' is not null or undefined
        if (tagListOp === null || tagListOp === undefined) {
            throw new Error('Required parameter tagListOp was null or undefined when calling deleteTagRelationshipsLists.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagListOp, "TagListOp")
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body?: any;  }>( () => {
            return new Promise<{ response: AxiosResponse; body?: any;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Remove a tag\'s association with one or more segments.   Use the request body to pass in the ID(s) of the segments(s) whose association with the tag will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `segments:write` `tags:write`
     * @summary Delete Tag Relationships Segments
     * @param id * @param tagSegmentOp 
     
     */
    public async deleteTagRelationshipsSegments (id: string, tagSegmentOp: TagSegmentOp, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/segments/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTagRelationshipsSegments.');
        }

        // verify required parameter 'tagSegmentOp' is not null or undefined
        if (tagSegmentOp === null || tagSegmentOp === undefined) {
            throw new Error('Required parameter tagSegmentOp was null or undefined when calling deleteTagRelationshipsSegments.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagSegmentOp, "TagSegmentOp")
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body?: any;  }>( () => {
            return new Promise<{ response: AxiosResponse; body?: any;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Retrieve the tag with the given tag ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tag
     * @param id The Tag ID
     * @param fieldsTagGroup For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#sparse-fieldsets* @param fieldsTag For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#sparse-fieldsets* @param include For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#relationships
     */
    public async getTag (id: string, options: { fieldsTagGroup?: Array<'name' | 'exclusive' | 'default'>, fieldsTag?: Array<'name'>, include?: Array<'tag-group'>,  } = {}): Promise<{ response: AxiosResponse; body: GetTagResponseCompoundDocument;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTag.');
        }

        if (options.fieldsTagGroup !== undefined) {
            localVarQueryParameters['fields[tag-group]'] = ObjectSerializer.serialize(options.fieldsTagGroup, "Array<'name' | 'exclusive' | 'default'>");
        }

        if (options.fieldsTag !== undefined) {
            localVarQueryParameters['fields[tag]'] = ObjectSerializer.serialize(options.fieldsTag, "Array<'name'>");
        }

        if (options.include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(options.include, "Array<'tag-group'>");
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: GetTagResponseCompoundDocument;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: GetTagResponseCompoundDocument;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagResponseCompoundDocument");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Retrieve the tag group with the given tag group ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tag Group
     * @param id The Tag Group ID
     * @param fieldsTagGroup For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#sparse-fieldsets
     */
    public async getTagGroup (id: string, options: { fieldsTagGroup?: Array<'name' | 'exclusive' | 'default'>,  } = {}): Promise<{ response: AxiosResponse; body: GetTagGroupResponse;  }> {

        const localVarPath = this.basePath + '/api/tag-groups/{id}/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagGroup.');
        }

        if (options.fieldsTagGroup !== undefined) {
            localVarQueryParameters['fields[tag-group]'] = ObjectSerializer.serialize(options.fieldsTagGroup, "Array<'name' | 'exclusive' | 'default'>");
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: GetTagGroupResponse;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: GetTagGroupResponse;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagGroupResponse");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Returns the tag IDs of all tags inside the given tag group.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tag Group Relationships Tags
     * @param id 
     
     */
    public async getTagGroupRelationshipsTags (id: string, ): Promise<{ response: AxiosResponse; body: GetTagGroupTagRelationshipsResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tag-groups/{id}/relationships/tags/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagGroupRelationshipsTags.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: GetTagGroupTagRelationshipsResponseCollection;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: GetTagGroupTagRelationshipsResponseCollection;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagGroupTagRelationshipsResponseCollection");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Return the tags for a given tag group ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tag Group Tags
     * @param id 
     * @param fieldsTag For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#sparse-fieldsets
     */
    public async getTagGroupTags (id: string, options: { fieldsTag?: Array<'name'>,  } = {}): Promise<{ response: AxiosResponse; body: GetTagResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tag-groups/{id}/tags/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagGroupTags.');
        }

        if (options.fieldsTag !== undefined) {
            localVarQueryParameters['fields[tag]'] = ObjectSerializer.serialize(options.fieldsTag, "Array<'name'>");
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: GetTagResponseCollection;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: GetTagResponseCollection;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagResponseCollection");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * List all tag groups in an account. Every account has one default tag group.  Tag groups can be filtered by `name`, `exclusive`, and `default`, and sorted by `name` or `id` in ascending or descending order.  Returns a maximum of 25 tag groups per request, which can be paginated with [cursor-based pagination](https://developers.klaviyo.com/en/v2022-10-17/reference/api_overview#pagination).<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tag Groups
     
     * @param fieldsTagGroup For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#sparse-fieldsets* @param filter For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;name&#x60;: &#x60;contains&#x60;, &#x60;ends-with&#x60;, &#x60;equals&#x60;, &#x60;starts-with&#x60;&lt;br&gt;&#x60;exclusive&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;default&#x60;: &#x60;equals&#x60;* @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#pagination* @param sort For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#sorting
     */
    public async getTagGroups (options: { fieldsTagGroup?: Array<'name' | 'exclusive' | 'default'>, filter?: string, pageCursor?: string, sort?: 'id' | '-id' | 'name' | '-name',  } = {}): Promise<{ response: AxiosResponse; body: GetTagGroupResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tag-groups/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        if (options.fieldsTagGroup !== undefined) {
            localVarQueryParameters['fields[tag-group]'] = ObjectSerializer.serialize(options.fieldsTagGroup, "Array<'name' | 'exclusive' | 'default'>");
        }

        if (options.filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(options.filter, "string");
        }

        if (options.pageCursor !== undefined) {
            localVarQueryParameters['page[cursor]'] = ObjectSerializer.serialize(options.pageCursor, "string");
        }

        if (options.sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(options.sort, "'id' | '-id' | 'name' | '-name'");
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: GetTagGroupResponseCollection;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: GetTagGroupResponseCollection;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagGroupResponseCollection");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Returns the IDs of all campaigns associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `campaigns:read` `tags:read`
     * @summary Get Tag Relationships Campaigns
     * @param id 
     
     */
    public async getTagRelationshipsCampaigns (id: string, ): Promise<{ response: AxiosResponse; body: GetTagCampaignRelationshipsResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/campaigns/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagRelationshipsCampaigns.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: GetTagCampaignRelationshipsResponseCollection;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: GetTagCampaignRelationshipsResponseCollection;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagCampaignRelationshipsResponseCollection");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Returns the IDs of all flows associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `flows:read` `tags:read`
     * @summary Get Tag Relationships Flows
     * @param id 
     
     */
    public async getTagRelationshipsFlows (id: string, ): Promise<{ response: AxiosResponse; body: GetTagFlowRelationshipsResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/flows/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagRelationshipsFlows.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: GetTagFlowRelationshipsResponseCollection;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: GetTagFlowRelationshipsResponseCollection;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagFlowRelationshipsResponseCollection");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Returns the IDs of all lists associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `list:read` `tags:read`
     * @summary Get Tag Relationships Lists
     * @param id 
     
     */
    public async getTagRelationshipsLists (id: string, ): Promise<{ response: AxiosResponse; body: GetTagListRelationshipsResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/lists/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagRelationshipsLists.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: GetTagListRelationshipsResponseCollection;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: GetTagListRelationshipsResponseCollection;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagListRelationshipsResponseCollection");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Returns the IDs of all segments associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `segments:read` `tags:read`
     * @summary Get Tag Relationships Segments
     * @param id 
     
     */
    public async getTagRelationshipsSegments (id: string, ): Promise<{ response: AxiosResponse; body: GetTagSegmentRelationshipsResponseCollection;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/segments/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagRelationshipsSegments.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: GetTagSegmentRelationshipsResponseCollection;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: GetTagSegmentRelationshipsResponseCollection;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagSegmentRelationshipsResponseCollection");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Returns the id of the tag group related to the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tag Relationships Tag Group
     * @param id 
     
     */
    public async getTagRelationshipsTagGroup (id: string, ): Promise<{ response: AxiosResponse; body: GetTagTagGroupRelationshipsResponse;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/relationships/tag-group/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagRelationshipsTagGroup.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: GetTagTagGroupRelationshipsResponse;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: GetTagTagGroupRelationshipsResponse;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagTagGroupRelationshipsResponse");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Returns the tag group resource for a given tag ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tag Tag Group
     * @param id 
     * @param fieldsTagGroup For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#sparse-fieldsets
     */
    public async getTagTagGroup (id: string, options: { fieldsTagGroup?: Array<'name' | 'exclusive' | 'default'>,  } = {}): Promise<{ response: AxiosResponse; body: GetTagGroupResponse;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/tag-group/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagTagGroup.');
        }

        if (options.fieldsTagGroup !== undefined) {
            localVarQueryParameters['fields[tag-group]'] = ObjectSerializer.serialize(options.fieldsTagGroup, "Array<'name' | 'exclusive' | 'default'>");
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: GetTagGroupResponse;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: GetTagGroupResponse;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagGroupResponse");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * List all tags in an account.  Tags can be filtered by `name`, and sorted by `name` or `id` in ascending or descending order.  Returns a maximum of 50 tags per request, which can be paginated with [cursor-based pagination](https://developers.klaviyo.com/en/v2022-10-17/reference/api_overview#pagination).<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read`
     * @summary Get Tags
     
     * @param fieldsTagGroup For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#sparse-fieldsets* @param fieldsTag For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#sparse-fieldsets* @param filter For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;name&#x60;: &#x60;contains&#x60;, &#x60;ends-with&#x60;, &#x60;equals&#x60;, &#x60;starts-with&#x60;* @param include For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#relationships* @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#pagination* @param sort For more information please visit https://developers.klaviyo.com/en/v2023-09-15/reference/api-overview#sorting
     */
    public async getTags (options: { fieldsTagGroup?: Array<'name' | 'exclusive' | 'default'>, fieldsTag?: Array<'name'>, filter?: string, include?: Array<'tag-group'>, pageCursor?: string, sort?: 'id' | '-id' | 'name' | '-name',  } = {}): Promise<{ response: AxiosResponse; body: GetTagResponseCollectionCompoundDocument;  }> {

        const localVarPath = this.basePath + '/api/tags/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        if (options.fieldsTagGroup !== undefined) {
            localVarQueryParameters['fields[tag-group]'] = ObjectSerializer.serialize(options.fieldsTagGroup, "Array<'name' | 'exclusive' | 'default'>");
        }

        if (options.fieldsTag !== undefined) {
            localVarQueryParameters['fields[tag]'] = ObjectSerializer.serialize(options.fieldsTag, "Array<'name'>");
        }

        if (options.filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(options.filter, "string");
        }

        if (options.include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(options.include, "Array<'tag-group'>");
        }

        if (options.pageCursor !== undefined) {
            localVarQueryParameters['page[cursor]'] = ObjectSerializer.serialize(options.pageCursor, "string");
        }

        if (options.sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(options.sort, "'id' | '-id' | 'name' | '-name'");
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'GET',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: GetTagResponseCollectionCompoundDocument;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: GetTagResponseCollectionCompoundDocument;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "GetTagResponseCollectionCompoundDocument");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Update the tag with the given tag ID.  Only a tag\'s `name` can be changed. A tag cannot be moved from one tag group to another.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read` `tags:write`
     * @summary Update Tag
     * @param id The Tag ID* @param tagUpdateQuery 
     
     */
    public async updateTag (id: string, tagUpdateQuery: TagUpdateQuery, ): Promise<{ response: AxiosResponse; body?: any;  }> {

        const localVarPath = this.basePath + '/api/tags/{id}/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTag.');
        }

        // verify required parameter 'tagUpdateQuery' is not null or undefined
        if (tagUpdateQuery === null || tagUpdateQuery === undefined) {
            throw new Error('Required parameter tagUpdateQuery was null or undefined when calling updateTag.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'PATCH',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagUpdateQuery, "TagUpdateQuery")
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body?: any;  }>( () => {
            return new Promise<{ response: AxiosResponse; body?: any;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
    /**
     * Update the tag group with the given tag group ID.  Only a tag group\'s `name` can be changed. A tag group\'s `exclusive` or `default` value cannot be changed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`  **Scopes:** `tags:read` `tags:write`
     * @summary Update Tag Group
     * @param id The Tag Group ID* @param tagGroupUpdateQuery 
     
     */
    public async updateTagGroup (id: string, tagGroupUpdateQuery: TagGroupUpdateQuery, ): Promise<{ response: AxiosResponse; body: PatchTagGroupResponse;  }> {

        const localVarPath = this.basePath + '/api/tag-groups/{id}/'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTagGroup.');
        }

        // verify required parameter 'tagGroupUpdateQuery' is not null or undefined
        if (tagGroupUpdateQuery === null || tagGroupUpdateQuery === undefined) {
            throw new Error('Required parameter tagGroupUpdateQuery was null or undefined when calling updateTagGroup.');
        }

        queryParamPreProcessor(localVarQueryParameters)

        let config: AxiosRequestConfig = {
            method: 'PATCH',
            url: localVarPath,
            headers: localVarHeaderParams,
            params: localVarQueryParameters,
            data: ObjectSerializer.serialize(tagGroupUpdateQuery, "TagGroupUpdateQuery")
        }

        this.session.applyToRequest(config)

        return backOff<{ response: AxiosResponse; body: PatchTagGroupResponse;  }>( () => {
            return new Promise<{ response: AxiosResponse; body: PatchTagGroupResponse;  }>((resolve, reject) => {
                axios(config)
                    .then(axiosResponse => {
                        let body;
                        body = ObjectSerializer.deserialize(axiosResponse.data, "PatchTagGroupResponse");
                        resolve({ response: axiosResponse, body: body });
                    })
                    .catch(error => {
                        reject(error);
                    })
            });
        }, this.session.getRetryOptions());
    }
}
